#!/bin/sh
DEBUG="0"
VERBOSE="0"
ELITE="0"
USERID=""
checkvm_status=""
MAC80211=0
WIRELESS_TOOLS="0"
IW_SOURCE="https://mirrors.edge.kernel.org/pub/software/network/iw/iw-6.9.tar.xz"
IW_ERROR=""
if [ ! -d '/sys/' ]; then
	printf "CONFIG_SYSFS is disabled in your kernel, this program will not work.\n"
  exit 1
fi
if [ -x "$(command -v mountpoint 2>&1)" ]; then
  if ! mountpoint -q -- /sys > /dev/null; then
    printf "/sys is not mounted, you can probably mount it with:\n"
    printf "mount -t sysfs sysfs /sys\n"
    printf "This program cannot continue without a working sysfs.\n"
    exit 1
  fi
fi
if [ ! -d '/sys/class' ]; then
  printf "This program cannot continue without a working sysfs.\n"
  printf "/sys/class is missing\n"
  exit 1
fi
if [ ! -d '/sys/class/net' ]; then
  printf "This program cannot continue without a working sysfs.\n"
  printf "/sys/class/net is missing\n"
  exit 1
fi

if [ "${1}" = "--elite" ]; then
	shift
	ELITE="1"
fi

if [ "${1}" = "--verbose" ]; then
	shift
	VERBOSE="1"
fi

if [ "${1}" = "--debug" ]; then
	shift
	DEBUG="1"
	VERBOSE="1"
fi

#yes, I know this is in here twice
if [ "${1}" = "--elite" ]; then
	shift
	ELITE="1"
fi


if [ -n "${3}" ];then
	if [ "${3}" -gt 0 ] > /dev/null 2>&1; then
		CH="${3}"
	else
		printf "\nYou have entered an invalid channel or frequency \"%s\" which will be ignored\n" "${3}"
		CH="0"
	fi
else
	CH="0"
fi

#TODO LIST

#cleanup getDriver()
#fix to not assume wifi drivers are modules
#rewrite to not have two devices at any one time

# We need root only when doing something, enumeration works as user
if [ -n "$(command -v id 2> /dev/null)" ]; then
  USERID="$(id -u 2> /dev/null)"
fi

if [ -z "${USERID}" ] && [ -n "$(id -ru)" ]; then
  USERID="$(id -ru)"
fi
if [ "${1}" = "check" ] || [ "${1}" = "start" ] || [ "${1}" = "stop" ]; then
  if [ -n "${USERID}" ] && [ "${USERID}" != "0" ]; then
    printf "Run it as root\n" ; exit 1;
  elif [ -z "${USERID}" ]; then
    printf "Unable to determine user id, permission errors may occur.\n"
  fi
fi

#check for all needed binaries
if [ ! -x "$(command -v uname 2>&1)" ]; then
	printf "How in the world do you not have uname installed?\n"
	printf "Please select a linux distro which has at least basic functionality (or install uname).\n"
	exit 1
fi

if [ ! -x "$(command -v ip 2>&1)" ] && [ ! -x "$(command -v ifconfig 2>&1)" ]; then
	printf "You have neither ip (iproute2) nor ifconfig installed.\n"
	printf "Please install one of them from your distro's package manager.\n"
	exit 1
fi

if [ ! -x "$(command -v iw 2>&1)" ]; then
	printf "You don't have iw installed, please install it from your distro's package manager.\n"
	printf "If your distro doesn't have a recent version you can download it from this link:\n"
	printf "%s\n" "${IW_SOURCE}"
	exit 1
fi

if [ ! -x "$(command -v ethtool 2>&1)" ]; then
	printf "Please install the ethtool package for your distro.\n"
	exit 1
fi

if [ -d /sys/bus/usb ]; then
	if [ ! -x "$(command -v lsusb 2>&1)" ]; then
		printf "Please install lsusb from your distro's package manager.\n"
		exit 1
	else
		LSUSB=1
	fi
else
	LSUSB=0
fi

if [ -x "$(command -v iwconfig 2>&1)" ]; then
  WIRELESS_TOOLS="1"
fi
wireless_tools_whine() {
  printf "This function requires deprecated wireless-tools to support your hardware/driver but it is not installed\n"
  printf "Please install the wireless-tools package for your distro, or use different hardware.\n"
  exit 1
}

if [ -d /sys/bus/pci ] || [ -d /sys/bus/pci_express ] || [ -d /proc/bus/pci ]; then
	PCI_DEVICES=0
	if [ -d /sys/bus/pci/devices ] && [ "$(find /sys/bus/pci/devices -type l 2>/dev/null | wc -l)" != '0' ]; then
		PCI_DEVICES=1
	elif [ -r /proc/bus/pci/devices ] && [ -n "$(cat /proc/bus/pci/devices 2>/dev/null)" ]; then
		PCI_DEVICES=1
	elif [ -d /sys/bus/pci_express/devices ] && [ "$(find /sys/bus/pci_express/devices -type l 2>/dev/null | wc -l)" != '0' ]; then
		PCI_DEVICES=1
	fi

	if [ ${PCI_DEVICES} -eq 0 ]; then
		LSPCI=0
	elif [ ! -x "$(command -v lspci 2>&1)" ]; then
		printf "Please install lspci from your distro's package manager.\n"
		exit 1
	else
		LSPCI=1
	fi
else
	LSPCI=0
fi

if [ -f /proc/modules ] || [ -d /sys/module ]; then
	if [ ! -x "$(command -v modprobe 2>&1)" ]; then
		printf "Your kernel has module support but you don't have modprobe installed.\n"
		printf "It is highly recommended to install modprobe (typically from kmod).\n"
		MODPROBE=0
	else
		MODPROBE=1
	fi
	if [ ! -x "$(command -v modinfo 2>&1)" ]; then
		printf "Your kernel has module support but you don't have modinfo installed.\n"
		printf "It is highly recommended to install modinfo (typically from kmod).\n"
		printf "Warning: driver detection without modinfo may yield inaccurate results.\n"
		MODINFO=0
	else
		MODINFO=1
	fi
else
	MODINFO=0
fi

if [ -c /dev/rfkill ]; then
	if [ ! -x "$(command -v rfkill 2>&1)" ];then
		printf "Your kernel supports rfkill but you don't have rfkill installed.\n"
		printf "To ensure devices are unblocked you must install rfkill.\n"
		RFKILL=0
	else
		RFKILL=1
	fi
else
	RFKILL=0
fi

if [ ! -x "$(command -v awk 2>&1)" ]; then
	printf "How in the world do you not have awk installed?\n"
	printf "Please select a linux distro which has at least basic functionality (or install awk).\n"
	exit 1
fi

if [ ! -x "$(command -v grep 2>&1)" ]; then
	printf "How in the world do you not have grep installed?\n"
	printf "Please select a linux distro which has at least basic functionality (or install grep).\n"
	exit 1
fi
#done checking for binaries

usage() {
  printf "usage: %s <start|stop|check> <interface> [channel or frequency]\n\n" "$(basename "$0")"
	exit 0
}

handleLostPhys() {
  MISSING_INTERFACE=""
  if [ -d /sys/class/ieee80211 ]; then
    for i in /sys/class/ieee80211/*; do
      if [ -e "${i}" ] && [ ! -d "${i}/device/net" ]; then
        MISSING_INTERFACE="${i##*/}"
        printf "\nFound %s with no interfaces assigned, would you like to assign one to it? [y/n] " "${MISSING_INTERFACE}"
        yesorno
        retcode=$?
        if [ "${retcode}" = "1" ]; then
          printf "PHY %s will remain lost.\n" "${MISSING_INTERFACE}"
        elif [ "${retcode}" = "0" ]; then
          PHYDEV=${MISSING_INTERFACE}
          findFreeInterface monitor
        fi
      fi
    done
  fi
  #add some spacing so this doesn't make the display hard to read
  printf "\n"
}

findFreeInterface() {
	if [ -z "${1}" ]; then
		printf "findFreeInterface needs a target mode.\n"
		exit 1
	fi
	if [ "${1}" != "monitor" ] && [ "${1}" != "station" ]; then
		printf "findFreeInterface only supports monitor and station for target mode.\n"
		exit 1
	fi
	target_mode="${1}"
	if [ "$target_mode" = "monitor" ]; then
		target_suffix="mon"
		target_type="803"
	else
		target_suffix=""
		target_type="1"
	fi
	for i in $(seq 0 100); do
		if [ "$i" = "100" ]; then
			printf "\n\tUnable to find a free name between wlan0 and wlan99, you are on your own from here.\n"
			return 1
		fi
		if [ "$DEBUG" = "1" ]; then
			printf "\nChecking candidate wlan%s\n" "${i}"
		fi
		if [ ! -e "/sys/class/net/wlan${i}" ]; then
			if [ "${DEBUG}" = "1" ]; then
				printf "\nCandidate wlan%s is not in use\n" "${i}"
			fi
			if [ ! -e "/sys/class/net/wlan${i}mon" ]; then
				if [ "$DEBUG" = "1" ]; then
					printf "\nCandidate wlan%s and wlan%smon are both clear, creating wlan%s%s\n" "${i}" "${i}" "${i}" "${target_suffix}"
				fi
				IW_ERROR="$(iw phy "${PHYDEV}" interface add "wlan${i}${target_suffix}" type "${target_mode}" 2>&1)"
				if [ -z "${IW_ERROR}" ]; then
					if [ -d "/sys/class/ieee80211/${PHYDEV}/device/net" ]; then
						#this should be fixed, but it's not going to be right now
						# shellcheck disable=2045
						for j in $(ls "/sys/class/ieee80211/${PHYDEV}/device/net/"); do
							if [ "$(cat "/sys/class/ieee80211/${PHYDEV}/device/net/${j}/type")" = "${target_type}" ]; then
								#here is where we catch udev renaming our interface
								k="${j#wlan}"
								i="${k%mon}"
							fi
						done
					else
						printf "Unable to create wlan%s%s and no error received.\n" "${i}" "${target_suffix}"
						return 1
					fi
                    printf "\n\t\t(mac80211 %s mode vif enabled on [%s]wlan%s%s)\n" "${target_mode}" "${PHYDEV}" "${i}" "${target_suffix}"
					unset IW_ERROR
					break
				else
					printf "\n\n ERROR adding %s mode interface: %s\n" "${target_mode}" "${IW_ERROR}"
					break
				fi
			else
				if [ "$DEBUG" = "1" ]; then
					printf "\nCandidate wlan%s does not exist, but wlan%smon does, skipping...\n" "${i}" "${i}"
				fi
			fi
		else
			if [ "$DEBUG" = "1" ]; then
				printf "\nCandidate wlan%s is in use already.\n" "${i}"
			fi
		fi
	done
}

rfkill_check() {
	#take phy and check blocks
	if [ "${RFKILL}" = 0 ]; then
		#immediately return if rfkill isn't supported
		return 0
	fi
	if [ -z "${1}" ]; then
		printf "Fatal, rfkill_check requires a phy to be passed in\n"
		exit 1
	fi
	#first we have to find the rfkill index
	#this is available as /sys/class/net/wlan0/phy80211/rfkill## but that's a bit difficult to parse
	index="$(rfkill list | grep "${1}:" | awk -F: '{print $1}')"
	if [ -z "$index" ]; then
		return 187
	fi
	rfkill_status="$(rfkill list "${index}" 2>&1)"
	# it's easier to capture and check this way, but a refactor could make it simpler and safer
	# shellcheck disable=2181
	if [ $? != 0 ]; then
		printf "rfkill error: %s\n" "${rfkill_status}"
		return 187
	elif [ -z "${rfkill_status}" ]; then
		printf "rfkill had no output, something went wrong.\n"
		exit 1
	else
		soft=$(printf "%s" "${rfkill_status}" | grep -i soft | awk '{print $3}')
		hard=$(printf "%s" "${rfkill_status}" | grep -i hard | awk '{print $3}')
		if [ "${soft}" = "yes" ] && [ "${hard}" = "no" ]; then
			return 1
		elif [ "${soft}" = "no" ] && [ "${hard}" = "yes" ]; then
			return 2
		elif [ "${soft}" = "yes" ] && [ "${hard}" = "yes" ]; then
			return 3
		fi
	fi
	return 0
}

rfkill_unblock() {
	#attempt unblock and CHECK SUCCESS
	if [ "${RFKILL}" = 0 ]; then
		#immediately return if rfkill isn't supported
		return 0
	fi
	if ! rfkill unblock "${1#phy}" 2>&1; then
		rfkill_status="$(rfkill unblock "${index}" 2>&1)"
		# it would be nice to refactor this, but it's easier this way
		# shellcheck disable=2181
		if [ $? != 0 ]; then
			if [ "$(printf "%s" "${rfkill_status}" | grep -c "Usage")" -eq 1 ]; then
				printf "Missing parameters in rfkill! Report this"
			else
				printf "rfkill error: %s\n" "${rfkill_status}"
			fi
			printf "Unable to unblock.\n"
			return 1
		fi
	fi

	sleep 1
	return 0
}

setLink() {
	if [ -x "$(command -v ip 2>&1)" ]; then
		ip link set dev "${1}" "${2}" > /dev/null 2>&1 || printf "\nFailed to set %s %s using ip\n" "${1}" "${2}"
	elif [ -x "$(command -v ifconfig 2>&1)" ]; then
		ifconfig "${1}" "${2}" > /dev/null 2>&1 || printf "\nFailed to set %s %s using ifconfig\n" "${1}" "${2}"
	fi
	return
}

ifaceIsUp() {
	if [ -x "$(command -v ip 2>&1)" ]; then
		ifaceIsUpCmd="ip link show dev"
	elif [ -x "$(command -v ifconfig 2>&1)" ]; then
		ifaceIsUpCmd="ifconfig"
	fi
	if ${ifaceIsUpCmd} "${1}" 2>&1 | grep -q UP
	then
		return
	else
		return 1
	fi
}

ifaceExists() {
	if [ -x "$(command -v ip 2>&1)" ]; then
		ifaceExistsCmd="ip link show dev"
	elif [ -x "$(command -v ifconfig 2>&1)" ]; then
		ifaceExistsCmd="ifconfig"
	fi
	if ${ifaceExistsCmd} "${1}" > /dev/null 2>&1
	then
		return
	else
		return 1
	fi
}

startDeprecatedIface() {
  # This function is here only for emergency.  If a driver calls it, add it to the list.
  # This function is currently called by: NOTHING
  if [ "${WIRELESS_TOOLS}" = "1" ];then
    if iwconfig "${1}" | grep -q 'Monitor'
    then
      printf "\t\t(Monitor mode already enabled for [%s]%s)\n" "${PHYDEV}" "${1}"
      return
    fi
    setLink "${1}" down
    iwconfig "${1}" mode monitor > /dev/null 2>&1
    if [ -n "${2}" ]; then
      if [ "${2}" -lt 1000 ]; then
        iwconfig "${1}" channel "${2}" > /dev/null 2>&1
      else
        iwconfig "${1}" freq "${2}000000" > /dev/null 2>&1
      fi
    else
      iwconfig "${1}" channel "${CH}" > /dev/null 2>&1
    fi
    iwconfig "${1}" key off > /dev/null 2>&1
    setLink "${1}" up
    printf "\t\t(monitor mode enabled)\n"
  else
    wireless_tools_whine
  fi
}

changeMac80211IfaceTypeMonitor() {
  iw dev "${1}" set type monitor > /dev/null 2>&1
  setLink "${1}" up
  printf "\t\t(monitor mode enabled)\n"
}

qcaldSafetyCheck() {
  icnss_file="/sys/module/wlan/parameters/con_mode"
  if [ ! -f "${icnss_file}" ]; then
    printf "Unable to find %s which is needed to control mode.\n" "${icnss_file}"
    printf "Is /sys mounted correctly?\n"
    exit 1
  fi
  if [ ! -w "${icnss_file}" ]; then
    printf "%s is present but we do not have write permission\n" "${icnss_file}"
    printf "Unable to control mode, giving up\n"
    exit 1
  fi
}

changeQcacldIfaceTypeMonitor() {
  #this is far too fragile for me, since it obviously doesn't
  #work if you have multiple cards with this driver
  #hopefully that never happens
  qcaldSafetyCheck
  echo 4 > /sys/module/wlan/parameters/con_mode
  setLink "${1}" up
  printf "\t\t(monitor mode enabled)\n"
}

yesorno() {
	read -r input
	case $input in
		y) return 0 ;;
		yes) return 0 ;;
		n) return 1 ;;
		no) return 1 ;;
		*) printf "\nInvalid input. Yes, or no? [y/n] "
		   yesorno;;
	esac
}

startMac80211Iface() {
	#check if rfkill is set and cry if it is
	rfkill_check "${PHYDEV}"
	rfkill_retcode="$?"
	case ${rfkill_retcode} in
		1) printf "\t%s is soft blocked, please run \"rfkill unblock %s\" to use this interface.\n" "${1}" "${index}" ;;
		2) printf "\t%s is hard blocked, please flip the hardware wifi switch (or in BIOS) to on.\n"a "${1}"
		   printf "\tIt may also be possible to unblock with \"rfkill unblock %s\"\n" "${index}"
		   if [ "${checkvm_status}" != "run" ]; then
		   	checkvm
		   fi
		   if [ -n "${vm}" ]; then
		   	printf "Detected VM using %s\n" "${vm_from}"
		   	printf "This appears to be a %s Virtual Machine\n" "${vm}"
		   	printf "Some distributions have bugs causing rfkill hard block to be forced on in a VM.\n"
		   	printf "If toggling the rfkill hardware switch and \"rfkill unblock %s\" both fail\n" "${index}"
		   	printf "to fix this, please try not running in a VM.\n"
		   fi
		   ;;
		3) printf "\t%s is hard and soft blocked, please flip the hardware wifi switch to on.\n" "${1}"
		   printf "\tIt may also be needed to unblock with \"rfkill unblock %s\"\n" "${index}" ;;
	esac
	if [ "${rfkill_retcode}" != 0 ]; then
		printf "rfkill error, unable to start %s\n\n" "${1}"
		printf "Would you like to try and automatically resolve this? [y/n] "
		yesorno
		retcode="$?"
		if [ "${retcode}" = "1" ]; then
			return 1
		elif [ "${retcode}" = "0" ]; then
			rfkill_unblock "${PHYDEV}"
		fi
	fi
	#check if $1 already has a mon interface on the same phy and bail if it does
	if [ -d "/sys/class/ieee80211/${PHYDEV}/device/net" ]; then
		for i in "/sys/class/ieee80211/${PHYDEV}/device/net"/*/"type"; do
			if [ -e "${i}" ] && [ "$(cat "${i}")" = "803" ]; then
				i=${i%/*}
				i=${i##*/}
				setChannelMac80211 "${i}"
				printf "\t\t(mac80211 monitor mode already enabled for [%s]%s on [%s]%s)\n" "${PHYDEV}" "${1}" "${PHYDEV}" "${i}"
				exit
			fi
		done
	fi
  #handle Qualcomm qcacld
  if [ "${DRIVER}" = "icnss" ]; then
    setLink "${1}" down
    changeQcacldIfaceTypeMonitor "${1}"
    setChannelMac80211 "${1}"
    return
  fi
  #check if chipset has driver not under mac80211 stack
  if [ "${DRIVER}" = "88XXau" ] || iw phy "${PHYDEV}" info | grep -q 'interface combinations are not supported'; then
    #grumble grumble, seriously crap vendor driver
    setLink "${1}" down
    changeMac80211IfaceTypeMonitor "${1}"
    setChannelMac80211 "${1}"
    return
  fi
	#we didn't bail means we need a monitor interface
	if [ ${#1} -gt 12 ]; then
		printf "Interface %smon is too long for linux so it will be renamed to the old style (wlan#) name.\n" "${1}"
		findFreeInterface monitor
	else
		if [ -e "/sys/class/net/${1}mon" ]; then
			printf "\nYou already have a %smon device but it is NOT in monitor mode." "${1}"
			printf "\nWhatever you did, don't do it again."
			printf "\nPlease run \"iw %smon del\" before attempting to continue\n" "${1}"
			exit 1
		fi
		#we didn't bail means our target interface is available
		setLink "${1}" down
		IW_ERROR="$(iw phy "${PHYDEV}" interface add "${1}mon" type monitor 2>&1)"
		if [ -z "${IW_ERROR}" ]; then
			sleep 1
			if [ -r "/sys/class/ieee80211/${PHYDEV}/device/net/${1}mon/type" ] && [ "$(cat "/sys/class/ieee80211/${PHYDEV}/device/net/${1}mon/type")" = "803" ]; then
				setChannelMac80211 "${1}mon"
			else
				printf "\nNewly created monitor mode interface %smon is *NOT* in monitor mode.\n" "${1}"
				printf "Removing non-monitor %smon interface...\n" "${1}"
				stopMac80211Iface "${1}mon" abort
				exit 1
			fi
			printf "\t\t(mac80211 monitor mode vif enabled for [%s]%s on [%s]%smon)\n" "${PHYDEV}" "${1}" "${PHYDEV}" "${1}"
		else
			printf "\nERROR adding monitor mode interface: %s\n" "${IW_ERROR}"
			exit 1
		fi
	fi
	if [ "${ELITE}" = "1" ]; then
		#check if $1 is still down, warn if not
		if ifaceIsUp "${1}"
		then
			printf "\nInterface %s is up, but it should be down. Something is interfering." "${1}"
			printf "\nPlease run \"airmon-ng check kill\" and/or kill your network manager."
		fi
	else
		isRPiWireless && iw "${1}" del
		printf "\t\t(mac80211 station mode vif disabled for [%s]%s)\n" "${PHYDEV}" "${1}"
	fi
}

isRPiWireless() {
	HW_REV="$(grep Revision /proc/cpuinfo | awk '{print $3}')"
	[ -z "${HW_REV}" ] && return 0
	# http://www.raspberrypi-spy.co.uk/2012/09/checking-your-raspberry-pi-board-version/
	# https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md
	[ "${HW_REV}" = 'a22082' ] && return 1
	[ "${HW_REV}" = 'a32082' ] && return 1
	[ "${HW_REV}" = 'a52082' ] && return 1
	[ "${HW_REV}" = 'a02082' ] && return 1
	[ "${HW_REV}" = '9000c1' ] && return 1
	[ "${HW_REV}" = 'a020d3' ] && return 1
	[ "${HW_REV}" = '9020e0' ] && return 1
	[ "${HW_REV}" = '9020e0' ] && return 1
	[ "${HW_REV}" = 'a22083' ] && return 1
	[ "${HW_REV}" = 'a020a0' ] && return 1
	[ "${HW_REV}" = 'a220a0' ] && return 1
	[ "${HW_REV}" = 'a02100' ] && return 1
	[ "${HW_REV}" = 'a03111' ] && return 1
	[ "${HW_REV}" = 'b03111' ] && return 1
	[ "${HW_REV}" = 'c03111' ] && return 1
	[ "${HW_REV}" = 'b03112' ] && return 1
	[ "${HW_REV}" = 'b03114' ] && return 1
	[ "${HW_REV}" = 'c03112' ] && return 1
	[ "${HW_REV}" = 'c03114' ] && return 1
	[ "${HW_REV}" = 'd03114' ] && return 1
	[ "${HW_REV}" = 'c03130' ] && return 1
	[ "${HW_REV}" = 'a03140' ] && return 1
	[ "${HW_REV}" = 'b03140' ] && return 1
	[ "${HW_REV}" = 'c03140' ] && return 1
	[ "${HW_REV}" = 'd03140' ] && return 1
	return 0
}

startwlIface() {
	if [ -f "/proc/brcm_monitor0" ]; then
		if [ -r "/proc/brcm_monitor0" ]; then
			brcm_monitor="$(cat /proc/brcm_monitor0)"
			if [ "$brcm_monitor" = "1" ]; then
				printf "\n\t\t(experimental wl monitor mode vif already enabled for [%s]%s on [%s]prism0)\n" "${PHYDEV}" "${1}" "${PHYDEV}"
				return 0
			fi
		fi
		if [ -w "/proc/brcm_monitor0" ]; then
			if printf "1" > /proc/brcm_monitor0; then
				printf "\n\t\t(experimental wl monitor mode vif enabled for [%s]%s on [%s]prism0)\n" "${PHYDEV}" "${1}" "${PHYDEV}"
			else
				printf "\n\t\t(failed to enable experimental wl monitor mode for [%s]%s)\n" "${PHYDEV}" "${1}"
			fi
		else
			printf "\n\tUnable to write to /proc/brcm_monitor0, cannot enable monitor mode.\n"
		fi
	else
		printf "\n\tThis version of wl does not appear to support monitor mode.\n"
	fi
}

#startDarwinIface() {
#	if [ -x /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport ]; then
#		if [ -n "${CH}" ] && [ ${CH} -lt 220 ]; then
#			/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport $1 sniff ${CH}
#		else
#			printf "Channel is set to none channel value of ${CH}
#		fi
#	fi
#}

setChannelMac80211() {
  setLink "${1}" up
  if [ -n "${CH}" ]; then
    # if channel is less than 900 assume it's a channel and try to set it as a channel
    # wil6210 driver doesn't support setting by channel afaict so jump it to the else
    if [ "${CH}" -lt 900 ] && [ "${DRIVER}" != "wil6210" ]; then
      if [ -r "/sys/class/net/$1/phy80211/name" ]; then
        channel_list="$(iw phy "$(cat "/sys/class/net/${1}/phy80211/name")" channels 2>&1 | awk -F'[][]' '$2{print $2}')"
        if [ -n "${channel_list}" ]; then
          hardware_valid_channel=1
          for supported_channel in ${channel_list}; do
            if [ "${CH}" = "0" ]; then
              # channel 0 means default, default means set first supported channel
              CH="${supported_channel}"
              hardware_valid_channel=0
              break
            fi
            if [ "${CH}" = "${supported_channel}" ]; then
              hardware_valid_channel=0
              break
            fi
            last_chan="${supported_channel}"
          done
          if [ "${hardware_valid_channel}" = "1" ]; then
            printf "Channel %s does not appear to be supported by %s hardware, defaulting to known valid channel %s\n\n" "${CH}" "${1}" "${last_chan}"
            CH="${last_chan}"
          fi
        else
          printf "Hardware %s supported channel list is empty, giving up.\n" "${1}"
          exit 1
        fi
      fi
      IW_ERROR="$(iw dev "${1}" set channel "${CH}" 2>&1)"
    # channel is 900 or over, assume it's a frequency and set it as such
    else
      if [ -r "/sys/class/net/$1/phy80211/name" ]; then
        frequency_list="$(iw phy "$(cat "/sys/class/net/${1}/phy80211/name")" channels 2>&1 | sed -nr 's/.*( |^)([0-9]+) MHz .*/\2/p')"
        if [ -n "${frequency_list}" ]; then
          hardware_valid_freq=1
          for supported_freq in $frequency_list; do
            if [ "${CH}" = "0" ]; then
              # channel 0 means default, default means set first supported freq
              CH="${supported_freq}"
              hardware_valid_freq=0
              break
            fi
            if [ "${CH}" = "${supported_freq}" ]; then
              hardware_valid_freq=0
              break
            fi
            last_freq="${supported_freq}"
          done
          if [ "${hardware_valid_freq}" = "1" ]; then
            printf "Frequency %s does not appear to be supported by %s hardware, defaulting to known valid freq %s Mhz\n\n" "${CH}" "${1}" "${last_freq}"
            CH="${last_freq}"
          fi
        else
          printf "Hardware %s supported frequency list is empty, giving up.\n" "${1}"
          exit 1
        fi
      fi
      IW_ERROR="$(iw dev "${1}" set freq "${CH}" 2>&1)"
    fi
  else
    printf "CH is unset, this should not be possible.\n"
    exit 1
  fi
  if [ -n "${IW_ERROR}" ]; then
    printf "\nError setting channel: %s\n" "${IW_ERROR}"
    if printf "%s" "${IW_ERROR}" | grep -q '(-16)'; then
      printf "Error -16 likely means your card was set back to station mode by something.\n"
      printf "Removing non-monitor %s interface...\n" "${1}"
      stopMac80211Iface "${1}" abort
      exit 1
    fi
    if printf "%s" "${IW_ERROR}" | grep -q '(-22)'; then
      printf "Unable to set channel/frequency %s, most likely it is outside of regulatory domain\n\n" "${CH}"
    fi
  fi
}

stopDeprecatedIface() {
  # This function is here only for emergency.  If a driver calls it, add it to the list.
  # This function is currently called by: NOTHING
  if [ "${WIRELESS_TOOLS}" = "1" ];then
    if iwconfig "${1}" | grep -q 'Managed'
    then
      printf "\t\t(Monitor mode already disabled for [%s]%s)\n" "${PHYDEV}" "${1}"
      return
    fi
    setLink "${1}" down
    iwconfig "${1}" mode Managed > /dev/null 2>&1
    setLink "${1}" up
    printf "\t\t(monitor mode disabled)\n"
  else
    wireless_tools_whine
  fi
}

changeMac80211IfaceTypeManaged() {
  setLink "${1}" down
  iw dev "${1}" set type managed > /dev/null 2>&1
  setLink "${1}" up
  printf "\t\t(monitor mode disabled)\n"
}

changeQcacldIfaceTypeManaged() {
  setLink "${1}" down
  #stupidly unsafe with more than one card, oh well
  qcaldSafetyCheck
  echo 0 > /sys/module/wlan/parameters/con_mode
  setLink "${1}" up
  printf "\t\t(monitor mode disabled)\n"
}

stopMac80211Iface() {
	if [ -f "/sys/class/net/${1}/type" ]; then
		if [ "${2}" != "abort" ] && [ "$(cat "/sys/class/net/${1}/type")" != "803" ]; then
			printf "\nYou are trying to stop a device that isn't in monitor mode.\n"
			printf "Doing so is a terrible idea, if you really want to do it then you\n"
			printf "need to type 'iw %s del' yourself since it is a terrible idea.\n" "${1}"
			printf "Most likely you want to remove an interface called wlan[0-9]mon\n"
			printf "If you feel you have reached this warning in error,\n"
			printf "please report it.\n"
			exit 1
		else
			if [ "${DRIVER}" = "icnss" ]; then
				changeQcacldIfaceTypeManaged "${1}"
				return
			fi
			if [ "${DRIVER}" = "88XXau" ] || iw phy "${PHYDEV}" info | grep -q 'interface combinations are not supported'; then
				#grumble grumble, seriously crap vendor driver
				changeMac80211IfaceTypeManaged "${1}"
				return
			fi
			if [ "${ELITE}" = "0" ]; then
				need_sta=1
				if [ -d "/sys/class/ieee80211/${PHYDEV}/device/net" ]; then
					# this should be refactored, but it's very fragile so not today
					# shellcheck disable=2045
					for i in $(ls "/sys/class/ieee80211/${PHYDEV}/device/net/"); do
						if [ -r "/sys/class/ieee80211/${PHYDEV}/device/net/${i}/type" ] && [ "$(cat "/sys/class/ieee80211/${PHYDEV}/device/net/${i}/type")" = "1" ]; then
							[ "${2}" != "abort" ] && printf "\n\t\t(mac80211 station mode vif already available for [%s]%s on [%s]%s)\n" "${PHYDEV}" "${1}" "${PHYDEV}" "${i}"
							need_sta=0
						fi
					done
				fi
				if [ "${need_sta}" = "1" ] && [ -e "/sys/class/net/${1%mon}/phy80211/name" ]; then
					if [ "$(cat "/sys/class/net/${1%mon}/phy80211/name")" = "${PHYDEV}" ]; then
						printf "\nYou already have a %s device but it is NOT in station mode." "${1%mon}"
						printf "\nWhatever you did, don't do it again."
						printf "\nPlease run \"iw %s del\" before attempting to continue\n" "${1%mon}"
						exit 1
					else
						printf "\nYou already have a %s device, but it is not on the same phy as %s.\n" "${1%mon}" "${1}"
						printf "\nAttemping to pick a new name...\n"
						findFreeInterface station
					fi
				fi
				if [ "${need_sta}" = "1" ]; then
					IW_ERROR="$(iw phy "${PHYDEV}" interface add "${1%mon}" type station 2>&1)"
					if [ -z "${IW_ERROR}" ]; then
						# The sleep below is to deal with when udev renames the interface we just created
						# except it does it just slow enough that this check was passing before it did it.
						# I don't want to add long sleeps here, but there isn't another way to deal with it.
						sleep 1
						interface="${1%mon}"
						if [ -d "/sys/class/ieee80211/${PHYDEV}/device/net" ]; then
							# this should be refactored, but it's very fragile so not today
							# shellcheck disable=2045
							for i in $(ls "/sys/class/ieee80211/${PHYDEV}/device/net/"); do
								if [ "$(cat "/sys/class/ieee80211/${PHYDEV}/device/net/${i}/type")" = "1" ]; then
									#here is where we catch udev renaming our interface
									interface="${i}"
								fi
							done
						fi
						printf "\t\t(mac80211 station mode vif enabled on [%s]%s)\n" "${PHYDEV}" "${interface}"
					else
						printf "\n ERROR adding station mode interface: %s\n" "${IW_ERROR}"
					fi
				fi
			fi
			setLink "${1}" down
			IW_ERROR="$(iw dev "${1}" del 2>&1 | grep "nl80211 not found")"
			if [ -z "$IW_ERROR" ]; then
				if [ "${2}" != "abort" ]; then
					printf "\t\t(mac80211 monitor mode vif disabled for [%s]%s)\n" "${PHYDEV}" "${1}"
				elif [ "${2}" = "abort" ]; then
					printf "\nWARNING: unable to start monitor mode, please run \"airmon-ng check kill\"\n"
				fi
			else
				if [ -f "/sys/class/ieee80211/${PHYDEV}/remove_iface" ]; then
					printf "%s" "${1}" > "/sys/class/ieee80211/${PHYDEV}/remove_iface"
					printf "\t\t(mac80211 monitor mode vif disabled for [%s]%s)\n" "${PHYDEV}" "${1}"
				else
					printf "\n\nERROR: Neither the sysfs interface links nor the iw command is available.\n"
          printf "Please install the iw package from your distro, or download and install iw from\n%s\n" "${IW_SOURCE}"
				fi
			fi
		fi
	fi
}

stopwlIface() {
	if [ -f "/proc/brcm_monitor0" ]; then
		if [ -r "/proc/brcm_monitor0" ]; then
			brcm_monitor="$(cat /proc/brcm_monitor0)"
			if [ "$brcm_monitor" = "0" ]; then
				printf "\n\t\t(experimental wl monitor mode vif already disabled for [%s]%s)\n" "${PHYDEV}" "${1}"
				return 0
			fi
		fi
		if [ -w "/proc/brcm_monitor0" ]; then
			if printf "0" > /proc/brcm_monitor0; then
				printf "\n\t\t(experimental wl monitor mode vif disabled for [%s]%s)\n" "${PHYDEV}" "${1}"
			else
				printf "\n\t\t(failed to disable experimental wl monitor mode for [%s]%s)\n" "${PHYDEV}" "${1}"
			fi
		else
			printf "\n\tUnable to write to /proc/brcm_monitor0, cannot disable monitor mode.\n"
		fi
	else
		printf "\n\tThis version of wl does not appear to support monitor mode.\n"
	fi
}

getDriver() {
	unset DRIVER
	#standard detection path, this is all that is needed for proper drivers
	#DRIVER=$(printf "$ethtool_output" | awk '/driver/ {print $2}')

	#if $(modinfo -F filename ${DRIVER} > /dev/null 2>&1)
	#then
	#	true
	#else
	#	unset DRIVER
	#fi

	#if [ "$DRIVER" = "" ]
	#then
		if [ -f "/sys/class/net/$1/device/uevent" ]; then
			DRIVER="$(awk -F'=' '$1 == "DRIVER" {print $2}' "/sys/class/net/${1}/device/uevent")"
		fi
	#fi

	#here we test for driver usb, ath9k_htc,rt2870, possibly others show this
	if [ "$DRIVER" = "usb" ]; then
		BUSADDR="$(printf "%s" "${ethtool_output}" | awk '/bus-info/ {print $2}'):1.0"

		if [ "$DEBUG" = "1" ]; 	then
			printf "Warn ON: USB\n"
			printf "%s\n" "${BUSADDR}"
		fi

		if [ -n "$BUSADDR" ]; then
			if [ -f "/sys/class/net/${1}/device/${BUSADDR}/uevent" ]; then
				DRIVER="$(awk -F'=' '$1 == "DRIVER" {print $2}' "/sys/class/net/${1}/device/${BUSADDR}/uevent")"
			fi
		fi

		#here we can normalize driver names we don't like
		if [ "$DRIVER" = "rt2870" ]; then
			DRIVER="rt2870sta"
		fi
		if [ -f "/sys/class/net/${1}/device/idProduct" ]; then
			if [ "$(cat "/sys/class/net/${1}/device/idProduct")" = "3070" ]; then
				DRIVER="rt3070sta"
			fi
		fi
	fi
	if [ "$DRIVER" = "rtl8187L" ]; then
		DRIVER="r8187l"
	fi
	if [ "$DRIVER" = "rtl8187" ] && [ "$STACK" = "ieee80211" ]; then
		DRIVER="r8187"
	fi
	if [ "${DRIVER}" = "8812au" ] || [ "${DRIVER}" = "8814au" ] || [ "${DRIVER}" = "rtl88xxau" ] || [ "${DRIVER}" = "rtl88XXau" ]; then
		DRIVER="88XXau"
	fi
	if [ "$DRIVER" = "rtl8812au" ]; then
		DRIVER="8812au"
	fi

	#Here we will catch the broken lying drivers not caught above
	#currently this only functions for pci devices and not usb since lsusb has no -k option
	if [ "${MODINFO}" = "1" ]; then
		if modinfo -F filename "${DRIVER}"  > /dev/null 2>&1
		then
			true
		else
			save="${DRIVER}"

			if [ -n "${DEVICEID}" ] && [ "${BUS}" = "pci" ]; then
				DRIVER="$(lspci -d "${DEVICEID}" -k | awk '/modules/ {print $3}')"
			fi
			if [ -z "${BUS}" ] || [ "${BUS}" != 'sdio' ]; then
					unset DRIVER
			fi

			if [ -n "${save}" ] && [ -z "${DRIVER}" ] ; then
				DRIVER="${save}"
			fi
		fi
	fi
	if [ -z "${DRIVER}" ] ; then
		DRIVER="??????"
	fi
	if [ "${DEBUG}" = "1" ]; then
		printf "getdriver() %s\n" "${DRIVER}"
	fi
}

getFrom() {
	#from detection
	FROM="K"
	if [ "${MODINFO}" = "1" ] && [ -f /proc/modules ]; then
		if modinfo -F filename "${DRIVER}" 2>&1 | grep -q 'kernel/drivers'
		then
			FROM="K"
			#we add special handling here because we hate the vendor drivers AND they install in the wrong place
			if [ "$DRIVER" = "r8187" ]; then
				FROM="V"
			elif [ "$DRIVER" = "r8187l" ]; then
				FROM="V"
			elif [ "$DRIVER" = "rt5390sta" ]; then
				FROM="V"
			elif [ "${DRIVER}" = "8812au" ] || [ "${DRIVER}" = "8814au" ]; then
				FROM="V"
			fi
		elif modinfo -F filename "${DRIVER}" 2>&1 | grep -q 'updates/drivers'
		then
			FROM="C"
		elif modinfo -F filename "${DRIVER}" 2>&1 | grep -q 'misc'
		then
			FROM="V"
		elif modinfo -F filename "${DRIVER}" 2>&1 | grep -q 'staging'
		then
			FROM="S"
		else
			FROM="?"
		fi
	else
		FROM="K"
	fi
  #maybe add an 'intree' check?
	if [ "$DEBUG" = "1" ]; then
		printf "getFrom() %s\n" "${FROM}"
	fi
}

getFirmware() {
	FIRMWARE="$(printf "%s" "${ethtool_output}" | awk '/firmware-version/ {print $2}')"
	#ath9k_htc and intel firmware is a shorter version number than most so trap and make it pretty
	if [ "${DRIVER}" = "ath9k_htc" ] || [ "${DRIVER}" = "iwlwifi" ]; then
		FIRMWARE="$FIRMWARE\t"
	fi

	if [ "$FIRMWARE" = "N/A" ]; then
		FIRMWARE="$FIRMWARE\t"
	elif [ -z "$FIRMWARE" ]; then
		FIRMWARE="unavailable"
	fi

	if [ "$DEBUG" = "1" ]; then
		printf "getFirmware %s\n" "${FIRMWARE}"
	fi
}

getChipset() {
  #this needs cleanup, we shouldn't have multiple lines assigning chipset per bus
  #also clean up the horrible sed lines
  #fix this to be one line per bus
  #
  #test examples
  #lspci
  #0000:01:00.0 Network controller: Qualcomm Atheros QCA9980/9990 802.11ac Wireless Network Adapter
  #0001:01:00.0 Network controller: Qualcomm Atheros QCA9980/9990 802.11ac Wireless Network Adapter
  #0002:01:00.0 Network controller: Wilocity Ltd. Wil6200 802.11ad Wireless Network Adapter (rev 02)
  #0000:00:14.3 Network controller: Intel Corporation Device 7a70 (rev 11)
  #lsusb
  #?
  if [ -f "/sys/class/net/${1}/device/modalias" ]; then
    # refactor this soon
    # shellcheck disable=2166
    if [ "${BUS}" = "usb" ]; then
      if [ "${LSUSB}" = "1" ]; then
        BUSINFO="$(cut -d ":" -f 2 "/sys/class/net/${1}/device/modalias" | cut -b 1-10 | sed 's/^.//;s/p/:/')"
        CHIPSET="$(lsusb -d "${BUSINFO}" | head -n1 - | cut -f3- -d ":" | sed 's/^....//;s/ Network Connection//g;s/ Wireless.*Adapter//g;s/^ //')"
      elif [ "${LSUSB}" = "0" ]; then
        printf "Your system doesn't seem to support usb but we found usb hardware, please report this.\n"
        exit 1
      fi
      #yes the below line looks insane, but broadcom appears to define all the internal buses so we have to detect them here
    elif [ "${BUS}" = "pci" -o "${BUS}" = "pcmcia" ] && [ "${LSPCI}" = "1" ]; then
      if [ -f "/sys/class/net/${1}/device/vendor" ] && [ -f "/sys/class/net/${1}/device/device" ]; then
        DEVICEID="$(sed -e 's/0x//' "/sys/class/net/${1}/device/vendor"):$(sed -e 's/0x//' "/sys/class/net/${1}/device/device")"
        CHIPSET="$(lspci -d "${DEVICEID}" | head -n1 - | cut -f2- -d " " | sed -e 's/Wireless LAN Controller //g' -e 's/ Network Connection//g' -e 's/ Wireless.*Adapter//' -e 's/Network controller: //' -e 's/^ //')"
      else
        BUSINFO="$(printf "%s" "${ethtool_output}" | grep bus-info | cut -d ":" -f "3-" | sed 's/^ //')"
        CHIPSET="$(lspci | grep "${BUSINFO}" | head -n1 - | cut -f3- -d ":" | sed 's/Wireless LAN Controller //g;s/ Network Connection//g;s/ Wireless.*Adapter//;s/^ //')"
        DEVICEID="$(lspci -nn | grep "${BUSINFO}" | grep '[[0-9][0-9][0-9][0-9]:[0-9][0-9][0-9][0-9]' -o)"
      fi
    elif [ "${BUS}" = "sdio" ]; then
      if [ -f "/sys/class/net/${1}/device/vendor" ] && [ -f "/sys/class/net/${1}/device/device" ]; then
        DEVICEID="$(cat "/sys/class/net/${1}/device/vendor"):$(cat "/sys/class/net/${1}/device/device")"
      fi
      if [ "${DEVICEID}" = '0x02d0:0x4330' ]; then
        CHIPSET='Broadcom 4330'
      elif [ "${DEVICEID}" = '0x02d0:0x4329' ]; then
        CHIPSET='Broadcom 4329'
      elif [ "${DEVICEID}" = '0x02d0:0x4334' ]; then
        CHIPSET='Broadcom 4334'
      elif [ "${DEVICEID}" = '0x02d0:0xa94c' ]; then
        CHIPSET='Broadcom 43340'
      elif [ "${DEVICEID}" = '0x02d0:0xa94d' ]; then
        CHIPSET='Broadcom 43341'
      elif [ "${DEVICEID}" = '0x02d0:0x4324' ]; then
        CHIPSET='Broadcom 43241'
      elif [ "${DEVICEID}" = '0x02d0:0x4335' ]; then
        CHIPSET='Broadcom 4335/4339'
      elif [ "${DEVICEID}" = '0x02d0:0xa962' ]; then
        CHIPSET='Broadcom 43362'
      elif [ "${DEVICEID}" = '0x02d0:0xa9a6' ]; then
        CHIPSET='Broadcom 43430'
      elif [ "${DEVICEID}" = '0x02d0:0x4345' ]; then
        CHIPSET='Broadcom 43455'
      elif [ "${DEVICEID}" = '0x02d0:0x4354' ]; then
        CHIPSET='Broadcom 4354'
      elif [ "${DEVICEID}" = '0x02d0:0xa887' ]; then
        CHIPSET='Broadcom 43143'
      elif [ "${DEVICEID}" = '0x024c:0xb703' ]; then
        CHIPSET='Realtek RTL8723CS'
      else
        CHIPSET="unable to detect for sdio ${DEVICEID}"
      fi
    else
      CHIPSET="Not pci, usb, or sdio"
    fi
    #we don't do a check for usb here but it is obviously only going to work for usb
  elif [ -f "/sys/class/net/${1}/device/idVendor" ] && [ -f "/sys/class/net/${1}/device/idProduct" ]; then
    DEVICEID="$(cat "/sys/class/net/${1}/device/idVendor"):$(cat "/sys/class/net/${1}/device/idProduct")"
    if [ "${LSUSB}" = "1" ]; then
      CHIPSET="$(lsusb | grep -i "${DEVICEID}" | head -n1 - | cut -f3- -d ":" | sed 's/^....//;s/ Network Connection//g;s/ Wireless Adapter//g;s/^ //')"
    elif [ "${LSUSB}" = "0" ]; then
      CHIPSET="idVendor and idProduct found on non-usb device, please report this."
    fi
  elif [ "${DRIVER}" = "mac80211_hwsim" ]; then
    CHIPSET="Software simulator of 802.11 radio(s) for mac80211"
  elif printf "%s" "${ethtool_output}" | awk '/bus-info/ {print $2}' | grep -q bcma; then
    BUS="bcma"

    if [ "${DRIVER}" = "brcmsmac" ] || [ "${DRIVER}" = "brcmfmac" ] || [ "${DRIVER}" = "b43" ]; then
      CHIPSET="Broadcom on bcma bus, information limited"
    else
      CHIPSET="Unrecognized driver \"${DRIVER}\" on bcma bus"
    fi
  else
    CHIPSET="non-mac80211 device? (report this!)"
  fi

  if [ "${DEBUG}" = "1" ]; then
    printf "getchipset() %s\n" "${CHIPSET}"
    printf "BUS = %s\n" "${BUS}"
    printf "BUSINFO = %s\n" "${BUSINFO}"
    printf "DEVICEID = %s\n" "${DEVICEID}"
  fi
}

getBus() {
	if [ -f "/sys/class/net/${1}/device/modalias" ]; then
		BUS="$(cut -d ":" -f 1 "/sys/class/net/${1}/device/modalias")"
	fi
	if [ "${DEBUG}" = "1" ]; then
		printf "getBus %s\n" "${BUS}"
	fi
}

getStack() {
	if [ -z "$1" ]; then
		return
	fi

	if [ -d "/sys/class/net/${1}/phy80211/" ]; then
		MAC80211="1"
		STACK="mac80211"
	else
		MAC80211="0"
		STACK="ieee80211"
	fi

	if [ -e "/proc/sys/dev/${1}/fftxqmin" ]; then
		MAC80211="0"
		STACK="net80211"
	fi

	if [ "${DEBUG}" = "1" ]; then
		printf "getStack %s\n" "${STACK}"
	fi
}

getExtendedInfo() {
	#stuff rfkill info into extended if nothing else is there
	rfkill_check "${PHYDEV}"
	rfkill_retcode="$?"
	if [ "${rfkill_retcode}" = "1" ]; then
		EXTENDED="rfkill soft blocked"
	elif [ "${rfkill_retcode}" = "2" ]; then
		EXTENDED="rfkill hard blocked"
	elif [ "${rfkill_retcode}" = "3" ]; then
		EXTENDED="rfkill hard and soft blocked"
	fi

	if [ "$DRIVER" = "??????" ]; then
		EXTENDED="\t Failure detecting driver properly please report"
	fi

	#first we set all the real (useful) info we can find
	if [ -f "/sys/class/net/${1}/device/product" ]; then
		EXTENDED="\t$(cat "/sys/class/net/${1}/device/product")"
	fi

	#then we sweep for known broken drivers with no available better drivers
	if [ "$DRIVER" = "wl" ]; then
		if [ -f "/proc/brcm_monitor0" ]; then
			EXTENDED="Experimental monitor mode support"
		else
			EXTENDED="No known monitor support, try a newer version or b43"
		fi
	fi
	if [ "$DRIVER" = "brcmsmac" ]; then
		EXTENDED="Driver commonly referred to as brcm80211 (no injection yet)"
	fi
	if [ "$DRIVER" = "r8712u" ]; then
		EXTENDED="\t\t\t\tNo monitor or injection support"
	fi

	#lastly we detect all the broken drivers which have working alternatives
	if [ "${KVMAJOR}" -lt 26 ]; then
		printf "You are running a kernel older than 2.6, I'm surprised it didn't error before now."
	        if [ "$DEBUG" = "1" ]; then
			printf "%s %s\n" "${KVMAJOR}" "${KVMINOR}"
		fi
		exit 1
	fi

	if [ "$DRIVER" = "rt2870sta" ];	then
		if [ "$KVMAJOR" = "26" ] && [ "$KVMINOR" -ge "35" ]; then
			EXTENDED="\tBlacklist rt2870sta and use rt2800usb"
		else
			EXTENDED="\tUpgrade to kernel 2.6.35 or install compat-wireless stable"
		fi
		#add in a flag for "did you tell use to do X" and emit instructions
	elif [ "$DRIVER" = "rt3070sta" ]; then
		if [ "$KVMAJOR" = "26" ] && [ "$KVMINOR" -ge "35" ]; then
			EXTENDED="\tBlacklist rt3070sta and use rt2800usb"
		else
			EXTENDED="\tUpgrade to kernel 2.6.35 or install compat-wireless stable"
		fi
	elif [ "$DRIVER" = "rt5390sta" ]; then
		if [ "$KVMAJOR" = "26" ] && [ "$KVMINOR" -ge "39" ]; then
			EXTENDED="\tBlacklist rt5390sta and use rt2800usb"
		else
			EXTENDED="\tUpgrade to kernel 2.6.39 or install compat-wireless stable"
		fi
	elif [ "$DRIVER" = "ar9170usb" ]; then
		if [ "$KVMAJOR" = "26" ] && [ "$KVMINOR" -ge "37" ]; then
			EXTENDED="\tBlacklist ar9170usb and use carl9170"
		else
			EXTENDED="\tUpgrade to kernel 2.6.37 or install compat-wireless stable"
		fi
	elif [ "$DRIVER" = "arusb_lnx" ]; then
		if [ "$KVMAJOR" = "26" ] && [ "$KVMINOR" -ge "37" ]; then
			EXTENDED="\tBlacklist arusb_lnx and use carl9170"
		else
			EXTENDED="\tUpgrade to kernel 2.6.37 or install compat-wireless stable"
		fi
	elif [ "$DRIVER" = "r8187" ]; then
		if [ "$KVMAJOR" = "26" ] && [ "$KVMINOR" -ge "29" ]; then
			EXTENDED="\t\tBlacklist r8187 and use rtl8187 from the kernel"
		else
			EXTENDED="\t\tUpgrade to kernel 2.6.29 or install compat-wireless stable"
		fi
	elif [ "$DRIVER" = "r8187l" ]; then
		if [ "$KVMAJOR" = "26" ] && [ "$KVMINOR" -ge "29" ]; then
			EXTENDED="\t\tBlacklist r8187l and use rtl8187 from the kernel"
		else
			EXTENDED="\t\tUpgrade to kernel 2.6.29 or install compat-wireless stable"
		fi
	fi
	#okay, now I take overload to a new level
	#if there is nothing else here to complain about, show mode
	if [ -z "${EXTENDED}" ]; then
		if [ -r "/sys/class/net/${1}/type" ]; then
			NET_TYPE="$(cat "/sys/class/net/${1}/type")"
		elif [ -r "/sys/class/ieee80211/${PHYDEV}/device/net/${1}/type" ]; then
			NET_TYPE="$(cat "/sys/class/ieee80211/${PHYDEV}/device/net/${1}/type")"
		fi
		if [ -n "${NET_TYPE}" ]; then
			if [ "${NET_TYPE}" = "803" ]; then
				EXTENDED="mode monitor"
			elif [ "${NET_TYPE}" = "1" ]; then
				EXTENDED="mode managed"
			else
				EXTENDED="mode ${NET_TYPE} unknown"
			fi
		fi
	fi
}

scanProcesses() {
  #this test means it errored and said it was busybox since busybox doesn't print without error
  # this was written with ps because some systems don't have pgrep.  Adding another branch that uses pgrep won't help remove this code
  # shellcheck disable=2009
  if (ps -A 2>&1 | grep -q BusyBox)
  then
    #busybox in openwrt cannot handle -A but its output by default is -A
    psopts=""
  else
    psopts="-A"
  fi
  # this was written with ps because some systems don't have pgrep.  Adding another branch that uses pgrep won't help remove this code
  # shellcheck disable=2009
  if ( ps -o comm= 2>&1 | grep -q BusyBox )
  then
    #busybox in openwrt cannot handle -o
    pso="0"
  else
    pso="1"
  fi

  PROCESSES="wpa_action\|wpa_supplicant\|wpa_cli\|dhclient\|ifplugd\|dhcdbd\|dhcpcd\|udhcpc\|NetworkManager\|knetworkmanager\|avahi-autoipd\|avahi-daemon\|wlassistant\|wifibox\|net_applet\|wicd-daemon\|wicd-client\|iwd\|hostapd"
  #PS_ERROR="invalid\|illegal"

  if [ "${1}" = "kill" ]; then
    if [ -x "$(command -v systemctl 2>&1)" ]; then
      for service in network-manager NetworkManager avahi-daemon wicd; do
        if systemctl status "${service}" > /dev/null 2>&1; then
          killservice=1
          until systemctl stop "${service}" 2> /dev/null > /dev/null; do
            killservice=$((killservice + 1))
            if [ ${killservice} -gt 5 ]; then
              printf "Failed to stop %s, please stop it on your own.\n" "${service}"
              break
            fi
          done
        fi
      done
    fi
    servicecmd=""
    if [ -x "$(command -v service 2>&1)" ]; then
      servicecmd="service"
    elif [ -x "$(command -v rc-service 2>&1)" ]; then
      servicecmd="rc-service"
    fi
    if [ -n "${servicecmd}" ]; then
      for service in network-manager NetworkManager avahi-daemon wicd; do
        if "${servicecmd}" "${service}" status 2> /dev/null > /dev/null; then
          killservice=1
          until "${servicecmd}" "${service}" stop 2> /dev/null > /dev/null; do
            killservice=$((killservice + 1))
            if [ ${killservice} -gt 5 ]; then
              printf "Failed to stop %s, please stop it on your own.\n" "${service}"
              break
            fi
          done
        fi
      done
    fi
  fi

  unset match
  if [ "${pso}" = 1 ]; then
    # this was written with ps because some systems don't have pgrep.  Adding another branch that uses pgrep won't help remove this code
    # shellcheck disable=2009
    match="$(ps ${psopts} -o comm= | grep ${PROCESSES} | grep -vc grep)"
  elif [ "${pso}" = 0 ]; then
    #openwrt busybox grep hits on itself so we -v it out
    # this was written with ps because some systems don't have pgrep.  Adding another branch that uses pgrep won't help remove this code
    # shellcheck disable=2009
    match="$(ps ${psopts} | grep ${PROCESSES} | grep -vc grep)"
  fi
  if [ "${match}" -gt 0 ] && [ "${1}" != "kill" ]; then
    printf "Found %s processes that could cause trouble.\n" "${match}"
    printf "Kill them using 'airmon-ng check kill' before putting\n"
    printf "the card in monitor mode, they will interfere by changing channels\n"
    printf "and sometimes putting the interface back in managed mode\n\n"
  else
    if [ "${1}" != "kill" ] && [ -n "${1}" ]; then
      printf "No interfering processes found\n"
      return
    fi
  fi

  if [ "${match}" -gt 0 ]; then
    if [ "${1}" = "kill" ]; then
      printf "Killing these processes:\n\n"
    fi
    if [ "${pso}" = "1" ]; then
      # this was written with ps because some systems don't have pgrep.  Adding another branch that uses pgrep won't help remove this code
      # shellcheck disable=2009
      ps ${psopts} -o pid=PID -o comm=Name | grep "${PROCESSES}\|PID"
    else
      #openwrt busybox grep hits on itself so we -v it out
      # this was written with ps because some systems don't have pgrep.  Adding another branch that uses pgrep won't help remove this code
      # shellcheck disable=2009
      ps ${psopts} | grep "${PROCESSES}\|PID | grep -v grep"
    fi
    if [ "${1}" = "kill" ]; then
      #we have to use signal 9 because things like nm actually respawn wpa_supplicant too quickly
      if [ "${pso}" = "1" ]; then
        # this was written with ps because some systems don't have pgrep.  Adding another branch that uses pgrep won't help remove this code
        # shellcheck disable=2009
        for pid in $(ps ${psopts} -o pid= -o comm= | grep "${PROCESSES}" | awk '{print $1}'); do
          kill -9 "${pid}"
        done
      else
        #openwrt busybox grep hits on itself so we -v it out
        # this was written with ps because some systems don't have pgrep.  Adding another branch that uses pgrep won't help remove this code
        # shellcheck disable=2009
        for pid in $(ps ${psopts} | grep "${PROCESSES}" | grep -v grep | awk '{print $1}'); do
          kill -9 "${pid}"
        done
      fi
    fi
  fi

  printf "\n"

}

listInterfaces() {
  unset iface_list
  if [ -d '/sys/class/net' ]; then
    # refactor this for globs, but make sure it works across shells
    # shellcheck disable=2045
    for iface in $(ls -1 /sys/class/net)
    do
      if [ -f "/sys/class/net/${iface}/uevent" ]; then
        if grep -q 'DEVTYPE=wlan' "/sys/class/net/${iface}/uevent"
        then
          iface_list="${iface_list} ${iface}"
        fi
      fi
    done
  fi
  if [ "${WIRELESS_TOOLS}" = "1" ] && [ -x "$(command -v sort 2>&1)" ]; then
    for iface in $(iwconfig 2> /dev/null | sed -e 's/^\(\w*\)\s.*/\1/' -e '/^$/d'); do
      iface_list="${iface_list} ${iface}"
    done
    #                                           sort needs newline separated,   convert back after
    iface_list="$(printf "%s" "${iface_list}" | sed 's/ /\n/g' | sort -bu | sed ':a;N;$!ba;s/\n/ /g')"
  fi
}

getPhy() {
	if [ -z "${1}" ];	then
		return
	fi

	if [ "${MAC80211}" = "0" ]; then
		PHYDEV="null"
		return
	fi

	if [ -r "/sys/class/net/${1}/phy80211/name" ]; then
		PHYDEV="$(cat "/sys/class/net/${1}/phy80211/name")"
	fi
	if [ -d "/sys/class/net/${1}/phy80211/" ] && [ -z "${PHYDEV}" ]; then
		# refactor this for globs, but be careful of shell support
		# shellcheck disable=2012
		PHYDEV="$(ls -l "/sys/class/net/${1}/phy80211" | sed 's/^.*\/\([a-zA-Z0-9_-]*\)$/\1/')"
	fi
}

checkvm() {
  #this entire section of code is completely stolen from Carlos Perez's work in checkvm.rb for metasploit and rewritten (poorly) in sh
  #check loaded modules
  if [ -x "$(command -v lsmod 2>&1)" ]; then
    lsmod_data="$(lsmod 2>&1 | awk '{print $1}')"
    if [ -n "${lsmod}" ]; then
      printf "%s" "${lsmod_data}" | grep -iqE "vboxsf|vboxguest" 2> /dev/null && vm="VirtualBox"
      printf "%s" "${lsmod_data}" | grep -iqE "vmw_ballon|vmxnet|vmw" 2> /dev/null && vm="VMware"
      printf "%s" "${lsmod_data}" | grep -iqE "xen-vbd|xen-vnif" 2> /dev/null && vm="Xen"
      printf "%s" "${lsmod_data}" | grep -iqE "virtio_pci|virtio_net" 2> /dev/null && vm="Qemu/KVM"
      printf "%s" "${lsmod_data}" | grep -iqE "hv_vmbus|hv_blkvsc|hv_netvsc|hv_utils|hv_storvsc" && vm="MS Hyper-V"
      [ -n "${vm}" ] && vm_from="lsmod"
    fi
  fi

  #check scsi driver
  if [ -z "${vm_from}" ]; then
    if [ -r /proc/scsi/scsi ]; then
      grep -iq "vmware" /proc/scsi/scsi 2> /dev/null && vm="VMware"
      grep -iq "vbox" /proc/scsi/scsi 2> /dev/null && vm="VirtualBox"
      [ -n "${vm}" ] && vm_from="/pro/scsi/scsi"
    fi
  fi

  # Check IDE Devices
  if [ -z "${vm_from}" ];	then
    if [ -d /proc/ide ]; then
      ide_model="$(cat /proc/ide/hd*/model)"
      printf "%s" "${ide_model}" | grep -iq "vbox" 2> /dev/null && vm="VirtualBox"
      printf "%s" "${ide_model}" | grep -iq "vmware" 2> /dev/null && vm="VMware"
      printf "%s" "${ide_model}" | grep -iq "qemu" 2> /dev/null && vm="Qemu/KVM"
      printf "%s" "${ide_model}" | grep -iqE "virtual (hd|cd)" 2> /dev/null && vm="Hyper-V/Virtual PC"
      [ -n "${vm}" ] && vm_from="ide_model"
    fi
  fi

  # Check using lspci
  if [ -z "${vm_from}" ] && [ "${LSPCI}" = "1" ]; then
    lspci_data="$(lspci 2>&1)"
    printf "%s" "${lspci_data}" | grep -iq "vmware" 2> /dev/null && vm="VMware"
    printf "%s" "${lspci_data}" | grep -iq "virtualbox" 2> /dev/null && vm="VirtualBox"
    [ -n "${vm}" ] && vm_from="lspci"
  fi

  # Xen bus check
  ## XXX: Removing unsafe check
  # this check triggers if CONFIG_XEN_PRIVILEGED_GUEST=y et al are set in kconfig (debian default) even in not actually a guest

  # Check using lscpu
  if [ -z "${vm_from}" ]; then
    if [ -x "$(command -v lscpu 2>&1)" ]; then
      lscpu_data="$(lscpu 2>&1)"
      printf "%s" "${lscpu_data}" | grep -iq "Xen" 2> /dev/null && vm="Xen"
      printf "%s" "${lscpu_data}" | grep -iq "Microsoft" 2> /dev/null && vm="MS Hyper-V"
      [ -n "${vm}" ] && vm_from="lscpu"
    fi
  fi

  #Check vmnet
  if [ -z "${vm_from}" ]; then
    if [ -e /dev/vmnet ]; then
      vm="VMware"
      vm_from="/dev/vmnet"
    fi
  fi

  #Check dmi info
  if [ -z "${vm_from}" ]; then
    if [ -x "$(command -v dmidecode 2>&1)" ]; then
      dmidecode 2>&1 | grep -iq "microsoft corporation" 2> /dev/null && vm="MS Hyper-V"
      dmidecode 2>&1 | grep -iq "vmware" 2> /dev/null && vm="VMware"
      dmidecode 2>&1 | grep -iq "virtualbox" 2> /dev/null && vm="VirtualBox"
      dmidecode 2>&1 | grep -iq "qemu" 2> /dev/null && vm="Qemu/KVM"
      dmidecode 2>&1 | grep -iq "domu" 2> /dev/null && vm="Xen"
      [ -n "${vm}" ] && vm_from="dmi_info"
    fi
  fi

  # Check dmesg Output
  if [ -z "${vm_from}" ]; then
    if [ -n "${USERID}" ] && [ "${USERID}" = "0" ]; then
      if [ -x "$(command -v dmesg 2>&1)" ]; then
        while true; do
          if dmesg | grep -iqE "vboxbios|vboxcput|vboxfacp|vboxxsdt|(vbox cd-rom)|(vbox harddisk)"; then
            vm="VirtualBox"
            break
          fi
          if dmesg | grep -iqE "(vmware virtual ide)|(vmware pvscsi)|(vmware virtual platform)"; then
            vm="VMware"
            break
          fi
          if dmesg | grep -iqE "(xen_mem)|(xen-vbd)"; then
            vm="Xen"
            break
          fi
          if dmesg | grep -iqE "(qemu virtual cpu version)"; then
            vm="Qemu/KVM"
            break
          fi
          break
        done
        [ -n "${vm}" ] && vm_from="dmesg"
      fi
    fi
  fi
  checkvm_status="run"
}

kernel_breakage_check() {
  # Kernel 5.15 has broken radiotap headers due to commit 8c89f7b3d3f2. They are fixed in 5.15.5
  # See https://lore.kernel.org/all/20211109100203.c61007433ed6.I1dade57aba7de9c4f48d68249adbae62636fd98c@changeid/
  if [ "${KVMAJOR}" = "515" ] && [ "${KVMINOR}" -lt "5" ]; then
    printf "WARNING: This kernel likely has broken radiotap headers\n"
    printf "\ttherefore breaking tools relying on packet capture.\n"
    printf "\tThis is fixed in kernel 5.15.5 and later versions.\n\n"
  fi
}

#end function definitions
#begin execution

#here we check for any phys that have no interfaces to pick up The Lost Phys
handleLostPhys

listInterfaces

# Kernel version checks are used unconditionally so just set it during main
if [ -r '/proc/version_signature' ]; then
  #ubuntu and derivatives put the real kernel version here
  KV="$(awk '{print $3}' /proc/version_signature)"
else
  KV="$(uname -r | awk -F'-' '{print $1}')"
fi
KVMAJOR="$(printf "%s" "${KV}" | awk -F'.' '{print $1$2}')"
KVMINOR="$(printf "%s" "${KV}" | awk -F'.' '{print $3}')"
if [ "${KVMINOR}" = "0" ]; then
  # debian and derivatives always have 0 in minor for uname -r so we extract from uname -v
  KV="$(uname -v | awk '{sub(/-.*/, "", $4); print $4}')"
  KVMINOR="$(printf "%s" "${KV}" | awk -F'.' '{print $3}')"
  #make sure we extracted a number
  if ! printf "%s" "${KVMINOR}" | grep -q '[[:digit:]]*'; then
    KVMINOR='0'
  fi
fi

if [ "${1}" = "check" ] || [ "${1}" = "start" ]; then
	if [ "${VERBOSE}" = "0" ]; then
		# if verbose is set this was already run
		# but it's important so run it for everyone
		kernel_breakage_check
	fi
	if [ "${2}" = "kill" ]; then
		#if we are killing, tell scanProcesses that
		scanProcesses "${2}"
		exit
	elif [ "${1}" = "start" ]; then
		scanProcesses
	else
		scanProcesses
		exit
	fi
fi

if [ "$#" != "0" ]; then
	if [ "${1}" != "start" ] && [ "${1}" != "stop" ]; then
		usage
	fi

	if [ -z "${2}" ]; then
		usage
	fi
fi

#start/stop interface existence check
if [ "${1}" = "start" ] || [ "${1}" = "stop" ]; then
  if ! ifaceExists "${2}"; then
    printf "Requested device \"%s\" does not exist.\n" "${2}"
    printf "Run %s without any arguments to see available interfaces\n" "${0}"
    exit 1
  fi
fi

#startup checks complete, headers then main

if [ "$DEBUG" = "1" ]; then
	if [ -x "$(command -v readlink 2>&1)" ]; then
		printf "/bin/sh -> %s\n" "$(readlink -f /bin/sh)"
		if $(readlink -f /bin/sh) --version > /dev/null 2>&1
		then
      printf "%s\n" "$($(readlink -f /bin/sh) --version)"
		fi
	else
		ls -l /bin/sh
		if /bin/sh --version > /dev/null 2>&1
		then
			/bin/sh --version
		fi
	fi
fi

if [ "$VERBOSE" = "1" ]; then
	if [ -n "$(command -v lsb_release 2> /dev/null)" ]; then
		lsb_release -a | grep -iv 'n/a'
		printf "\n"
	fi
	uname -a
	kernel_breakage_check

	if iw reg get | grep -q 'country 00:'; then
		printf "Regulatory Domain appears to be unset, please consider setting it with 'iw reg set XX'\n"
		printf "https://wireless.wiki.kernel.org/en/users/documentation/iw#updating_your_regulatory_domain\n"
	else
		for regdomain in $(iw reg get | awk '/country/ {print substr($2,1,length($2)-1)}' | sort -u); do
			printf "Regulatory Domain set to %s, see 'iw reg get' for details\n" "${regdomain}"
		done
	fi

	checkvm
	if [ -n "${vm}" ]; then
		printf "Detected VM using %s\n" "${vm_from}"
		printf "This appears to be a %s Virtual Machine\n" "${vm}"
		printf "If your system supports VT-d, it may be possible to use PCI devices\n"
		printf "If your system does not support VT-d, you can only use USB wifi cards\n"
	fi

  printf "\nK indicates driver is from %s\n" "$(uname -r)"
	if [ "${MODPROBE}" = "1" ]; then
		modprobe compat > /dev/null 2>&1

		if [ -r /sys/module/compat/parameters/compat_version ]; then
			printf "C indicates driver is from %s\n" "$(cat /sys/module/compat/parameters/compat_version)"
		fi
	fi
	printf "V indicates driver comes directly from the vendor, almost certainly a bad thing\n"
	printf "S indicates driver comes from the staging tree, these drivers are meant for reference not actual use, BEWARE\n"
	printf "? indicates we do not know where the driver comes from... report this\n\n"
fi

if [ "${VERBOSE}" = "1" ]; then
	printf "\nX[PHY]Interface\t\tDriver[Stack]-FirmwareRev\t\tChipset\t\t\t\t\t\t\t\t\t\tExtended Info\n\n"
else
	printf "PHY\tInterface\tDriver\t\tChipset\n\n"
fi

for iface in $(printf "%s" "${iface_list}"); do
	unset ethtool_output DRIVER FROM FIRMWARE STACK MADWIFI MAC80211 BUS BUSADDR BUSINFO DEVICEID CHIPSET EXTENDED NET_TYPE PHYDEV ifacet DRIVERt FIELD1 FIELD1t FIELD2 FIELD2t CHIPSETt
	#add a RUNNING check here and up the device if it isn't already
	ethtool_output="$(ethtool -i "${iface}" 2>&1)"
	if [ "$ethtool_output" != "Cannot get driver information: Operation not supported" ]; then
		getStack  "${iface}"
		getBus "${iface}"
		getPhy "${iface}"
		getDriver "${iface}"
		getChipset "${iface}"
		if [ "${VERBOSE}" = "1" ]; then
			getFrom "${iface}"
			getFirmware "${iface}"
			getExtendedInfo "${iface}"
		fi
	else
 		CHIPSET="ethtool failed... driver is broken"
	fi

	#yes this really is the main output loop
	if [ "${VERBOSE}" = "1" ]; then
		#beautify output spacing (within reason)
		FIELD1="${FROM}[${PHYDEV}]${iface}"
		if [ ${#FIELD1} -gt 15 ]; then
			FIELD1t="\t"
		else
			FIELD1t="\t\t"
		fi
		FIELD2="${DRIVER}[${STACK}]-${FIRMWARE}"
		if [ ${#FIELD2} -gt 28 ]; then
			FIELD2t="\t"
		else
			FIELD2t="\t\t"
		fi
		if [ -n "${EXTENDED}" ]; then
			if [ ${#CHIPSET} -gt 70 ]; then
				CHIPSETt="\t"
			elif [ ${#CHIPSET} -gt 63 ]; then
				CHIPSETt="\t\t"
			elif [ ${#CHIPSET} -gt 56 ]; then
				CHIPSETt="\t\t\t"
			elif [ ${#CHIPSET} -gt 49 ]; then
				CHIPSETt="\t\t\t\t"
			elif [ ${#CHIPSET} -gt 39 ]; then
				CHIPSETt="\t\t\t\t\t"
			elif [ ${#CHIPSET} -gt 35 ]; then
				CHIPSETt="\t\t\t\t\t\t"
			# XXX YUP, 28 and 21 are now that same. mostly because this is all hardcoded and sucks
			elif [ ${#CHIPSET} -gt 28 ]; then
				CHIPSETt="\t\t\t\t\t\t\t"
			elif [ ${#CHIPSET} -gt 21 ]; then
				CHIPSETt="\t\t\t\t\t\t\t"
			elif [ ${#CHIPSET} -gt 14 ]; then
				CHIPSETt="\t\t\t\t\t\t\t\t"
			elif [ ${#CHIPSET} -gt 7 ]; then
				CHIPSETt="\t\t\t\t\t\t\t\t\t"
			else
				CHIPSETt="\t\t\t\t\t\t\t\t\t\t"
			fi
		fi
		# just plain hard to read
		# shellcheck disable=2059
		printf "${FROM}[${PHYDEV}]${iface}${FIELD1t}${DRIVER}[${STACK}]-${FIRMWARE}${FIELD2t}${CHIPSET}${CHIPSETt}${EXTENDED}\n"
	else
		#beautify output spacing (within reason, interface/driver max length is 15 and phy max length is 7))
		if [ ${#DRIVER} -gt 7 ]; then
			DRIVERt="\t"
		else
			DRIVERt="\t\t"
		fi
		if [ ${#iface} -gt 7 ]; then
			ifacet="\t"
		else
			ifacet="\t\t"
		fi
		# just plain hard to read
		# shellcheck disable=2059
		printf "${PHYDEV}\t${iface}${ifacet}${DRIVER}${DRIVERt}${CHIPSET}\n"
	fi

	if [ "${DRIVER}" = "wl" ]; then
		if [ "${1}" = "start" ] && [ "${2}" = "${iface}" ]; then
			startwlIface "${iface}"
		fi
		if [ "${1}" = "stop" ] && [ "${2}" = "${iface}" ]; then
			stopwlIface "${iface}"
		fi
	elif [ "${MAC80211}" = "1" ]; then
		if [ "${1}" = "start" ] && [ "${2}" = "${iface}" ]; then
			startMac80211Iface "${iface}"
		fi

		if [ "${1}" = "stop" ] && [ "${2}" = "${iface}" ]; then
			stopMac80211Iface "${iface}"
		fi
	fi
done

#end with some space
printf "\n"
